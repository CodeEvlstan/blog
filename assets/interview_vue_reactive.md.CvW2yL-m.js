import{_ as t,c as r,o as d,ae as o}from"./chunks/framework.CLNW5JS9.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/reactive.md","filePath":"interview/vue/reactive.md"}'),a={name:"interview/vue/reactive.md"};function c(i,e,n,l,s,u){return d(),r("div",null,e[0]||(e[0]=[o('<h3 id="vue2-的数据劫持机制" tabindex="-1">Vue2 的数据劫持机制 <a class="header-anchor" href="#vue2-的数据劫持机制" aria-label="Permalink to &quot;Vue2 的数据劫持机制&quot;">​</a></h3><p>Vue2 的响应式系统基于 ​Object.defineProperty​ 实现，核心步骤如下：</p><ol><li>​属性遍历与劫持​： 初始化时递归遍历 data 对象的每个属性，通过 Object.defineProperty 将其转换为带有 getter/setter 的访问器属性。在 getter 中收集依赖（如组件的渲染函数），在 setter 中触发更新。</li><li>​依赖收集与派发更新​： 每个属性对应一个 Dep 类实例（依赖管理器），当属性被访问时，当前 Watcher（订阅者）会被添加到 Dep 的订阅列表中；当属性修改时，Dep 会通知所有 Watcher 执行更新逻辑。</li><li>局限性​： ​数组处理不足​：无法直接监听数组索引变化（如 arr[0] = 1）和 length 修改，需重写数组的 push、pop 等方法。 ​动态属性监听缺失​：无法自动响应新增或删除的属性，需通过 Vue.set 或 Vue.delete 手动触发。</li></ol><h3 id="vue3-的数据劫持机制" tabindex="-1">Vue3 的数据劫持机制 <a class="header-anchor" href="#vue3-的数据劫持机制" aria-label="Permalink to &quot;Vue3 的数据劫持机制&quot;">​</a></h3><p>Vue3 采用 ​Proxy​ 替代 Object.defineProperty，实现更高效的响应式系统：</p><ol><li>​代理对象与拦截操作​： 使用 Proxy 创建目标对象的代理，通过 get 和 set 拦截器捕获属性的访问和修改。Proxy 支持拦截所有操作（包括新增/删除属性、数组索引变化等），无需遍历属性。</li><li>深度响应式处理​： 当访问嵌套对象时，自动递归将其转换为响应式代理，避免初始化时的性能损耗。</li><li>​依赖追踪优化​： 引入 effect 函数和 track/trigger 机制，通过 WeakMap 和 Map 结构动态追踪依赖关系，减少内存占用并提升性能。</li><li>优势​：</li></ol><ul><li>全面监听​：支持数组、动态属性、Map/Set 等复杂数据结构。</li><li>惰性代理​：仅在访问时处理嵌套对象，避免不必要的递归。</li></ul><h3 id="vue2与vue3-数据劫持的对比" tabindex="-1">Vue2与Vue3 数据劫持的对比 <a class="header-anchor" href="#vue2与vue3-数据劫持的对比" aria-label="Permalink to &quot;Vue2与Vue3 数据劫持的对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>对比维度</th><th>Vue2 (Object.defineProperty)</th><th>Vue3 (Proxy)</th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>遍历对象属性，通过 <code>Object.defineProperty</code> 逐个劫持，需递归初始化所有属性</td><td>通过 <code>Proxy</code> 代理整个对象，拦截所有操作，按需（惰性）递归处理嵌套对象</td></tr><tr><td><strong>数据劫持能力</strong></td><td>❌ 无法监听数组索引修改和 <code>length</code> 变化<br>❌ 无法自动监听动态新增/删除属性</td><td>✅ 支持数组索引修改和 <code>length</code> 变化<br>✅ 支持动态新增/删除属性</td></tr><tr><td><strong>性能</strong></td><td>⚠️ 初始化时递归遍历所有属性，性能损耗较大</td><td>✅ 按需劫持，访问时递归代理嵌套对象，内存占用更低</td></tr><tr><td><strong>兼容性</strong></td><td>✅ 支持 IE9+</td><td>❌ 不支持 IE（依赖 ES6 Proxy）</td></tr><tr><td><strong>API 设计</strong></td><td>基于 <code>Dep</code> 类和 <code>Watcher</code> 类实现依赖收集与派发更新</td><td>基于 <code>effect</code> 副作用函数和 <code>track</code>（追踪依赖）/<code>trigger</code>（触发更新）函数实现响应式</td></tr><tr><td><strong>复杂数据结构支持</strong></td><td>❌ 不支持 <code>Map</code>/<code>Set</code>/<code>WeakMap</code> 等</td><td>✅ 支持 <code>Map</code>/<code>Set</code>/<code>WeakMap</code> 等 ES6+ 数据结构</td></tr><tr><td><strong>代码维护性</strong></td><td>需要手动处理数组方法和动态属性，逻辑分散</td><td></td></tr></tbody></table><p>总结 ​Vue2​ 的 Object.defineProperty 机制简单但存在性能瓶颈和监听盲区，需通过额外方法弥补 。 ​Vue3​ 的 Proxy 提供了更高效、全面的响应式支持，尤其适合复杂应用场景 。 开发者可根据项目需求（如兼容性、性能）选择版本，Vue3 的响应式系统在灵活性和效率上显著领先</p>',10)]))}const g=t(a,[["render",c]]);export{h as __pageData,g as default};
