import{_ as o,C as d,c as r,o as c,G as a,ae as i,w as n,a as l}from"./chunks/framework.CLNW5JS9.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/reactive.md","filePath":"interview/vue/reactive.md"}'),s={name:"interview/vue/reactive.md"};function u(g,e,p,h,f,P){const t=d("Badge");return c(),r("div",null,[a(t,{type:"warning"},{default:n(()=>e[0]||(e[0]=[l("内容编写中")])),_:1}),e[1]||(e[1]=i('<h3 id="vue2-的数据劫持机制" tabindex="-1">Vue2 的数据劫持机制 <a class="header-anchor" href="#vue2-的数据劫持机制" aria-label="Permalink to &quot;Vue2 的数据劫持机制&quot;">​</a></h3><p>Vue2 的响应式系统基于 ​Object.defineProperty​ 实现，核心步骤如下：</p><ol><li><strong>​ 属性遍历与劫持 ​：</strong> 初始化时递归遍历 <code>data</code>对象的每个属性，通过 <code>Object.defineProperty</code> 将其转换为带有 <code>getter/setter</code> 的访问器属性。在 <code>getter</code> 中收集依赖（如组件的渲染函数），在 <code>setter</code> 中触发更新。</li><li>​ <strong>依赖收集与派发更新 ​：</strong> 每个属性对应一个 <code>Dep</code> 类实例（依赖管理器），当属性被访问时，当前 <code>Watcher</code>（订阅者）会被添加到 <code>Dep</code> 的订阅列表中；当属性修改时，<code>Dep</code> 会通知所有 <code>Watcher</code> 执行更新逻辑。</li><li><strong>局限性 ​：</strong></li></ol><ul><li>**​ 数组处理不足 ​：**无法直接监听数组索引变化（如 <code>arr[0] = 1</code>）和 <code>length</code> 修改，需重写数组的 <code>push</code>、<code>pop</code> 等方法。</li><li>**​ 动态属性监听缺失 ​：**无法自动响应新增或删除的属性，需通过 <code>Vue.set</code> 或 <code>Vue.delete</code> 手动触发。</li></ul><h3 id="vue3-的数据劫持机制" tabindex="-1">Vue3 的数据劫持机制 <a class="header-anchor" href="#vue3-的数据劫持机制" aria-label="Permalink to &quot;Vue3 的数据劫持机制&quot;">​</a></h3><p>Vue3 采用 ​Proxy​ 替代 Object.defineProperty，实现更高效的响应式系统：</p><ol><li><strong>​ 代理对象与拦截操作 ​：</strong> 使用 <code>Proxy</code> 创建目标对象的代理，通过 <code>get</code> 和 <code>set</code> 拦截器捕获属性的访问和修改。<code>Proxy</code> 支持拦截所有操作（包括新增/删除属性、数组索引变化等），无需遍历属性。</li><li><strong>深度响应式处理 ​：</strong> 当访问嵌套对象时，自动递归将其转换为响应式代理，避免初始化时的性能损耗。 3.** ​ 依赖追踪优化 ​：** 引入 <code>effect</code> 函数和 <code>track/trigger</code> 机制，通过 <code>WeakMap</code> 和 <code>Map</code> 结构动态追踪依赖关系，减少内存占用并提升性能。</li><li>优势 ​：</li></ol><ul><li>**全面监听 ​：**支持数组、动态属性、<code>Map/Set</code> 等复杂数据结构。</li><li>**惰性代理 ​：**仅在访问时处理嵌套对象，避免不必要的递归。</li></ul><h3 id="vue2-与-vue3-数据劫持的对比" tabindex="-1">Vue2 与 Vue3 数据劫持的对比 <a class="header-anchor" href="#vue2-与-vue3-数据劫持的对比" aria-label="Permalink to &quot;Vue2 与 Vue3 数据劫持的对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>对比维度</th><th>Vue2 (Object.defineProperty)</th><th>Vue3 (Proxy)</th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>遍历对象属性，通过 <code>Object.defineProperty</code> 逐个劫持，需递归初始化所有属性</td><td>通过 <code>Proxy</code> 代理整个对象，拦截所有操作，按需（惰性）递归处理嵌套对象</td></tr><tr><td><strong>数据劫持能力</strong></td><td>❌ 无法监听数组索引修改和 <code>length</code> 变化<br>❌ 无法自动监听动态新增/删除属性</td><td>✅ 支持数组索引修改和 <code>length</code> 变化<br>✅ 支持动态新增/删除属性</td></tr><tr><td><strong>性能</strong></td><td>⚠️ 初始化时递归遍历所有属性，性能损耗较大</td><td>✅ 按需劫持，访问时递归代理嵌套对象，内存占用更低</td></tr><tr><td><strong>兼容性</strong></td><td>✅ 支持 IE9+</td><td>❌ 不支持 IE（依赖 ES6 Proxy）</td></tr><tr><td><strong>API 设计</strong></td><td>基于 <code>Dep</code> 类和 <code>Watcher</code> 类实现依赖收集与派发更新</td><td>基于 <code>effect</code> 副作用函数和 <code>track</code>（追踪依赖）/<code>trigger</code>（触发更新）函数实现响应式</td></tr><tr><td><strong>复杂数据结构支持</strong></td><td>❌ 不支持 <code>Map</code>/<code>Set</code>/<code>WeakMap</code> 等</td><td>✅ 支持 <code>Map</code>/<code>Set</code>/<code>WeakMap</code> 等 ES6+ 数据结构</td></tr><tr><td><strong>代码维护性</strong></td><td>需要手动处理数组方法和动态属性，逻辑分散</td><td>统一通过 <code>Proxy</code> 拦截操作，代码更集中且可扩展性强</td></tr></tbody></table><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>​Vue2​ 的 <code>Object.defineProperty</code> 机制简单但存在性能瓶颈和监听盲区，需通过额外方法弥补 。</li><li>​Vue3​ 的 <code>Proxy </code>提供了更高效、全面的响应式支持，尤其适合复杂应用场景。 开发者可根据项目需求（如兼容性、性能）选择版本，Vue3 的响应式系统在灵活性和效率上显著领先</li></ul>',12))])}const b=o(s,[["render",u]]);export{_ as __pageData,b as default};
