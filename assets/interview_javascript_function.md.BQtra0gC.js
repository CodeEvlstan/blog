import{_ as e,c as i,o as t,ae as r}from"./chunks/framework.CLNW5JS9.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/javascript/function.md","filePath":"interview/javascript/function.md"}'),l={name:"interview/javascript/function.md"};function o(n,a,c,s,h,d){return t(),i("div",null,a[0]||(a[0]=[r('<h2 id="函数定义" tabindex="-1">函数定义 <a class="header-anchor" href="#函数定义" aria-label="Permalink to &quot;函数定义&quot;">​</a></h2><h2 id="具名函数表达式" tabindex="-1">具名函数表达式 <a class="header-anchor" href="#具名函数表达式" aria-label="Permalink to &quot;具名函数表达式&quot;">​</a></h2><h2 id="匿名函数表达式" tabindex="-1">匿名函数表达式 <a class="header-anchor" href="#匿名函数表达式" aria-label="Permalink to &quot;匿名函数表达式&quot;">​</a></h2><h2 id="自执行函数-iife" tabindex="-1">自执行函数（IIFE） <a class="header-anchor" href="#自执行函数-iife" aria-label="Permalink to &quot;自执行函数（IIFE）&quot;">​</a></h2><h2 id="函数是javascript中的一等公民" tabindex="-1">函数是javascript中的一等公民 <a class="header-anchor" href="#函数是javascript中的一等公民" aria-label="Permalink to &quot;函数是javascript中的一等公民&quot;">​</a></h2><h2 id="函数的调用栈" tabindex="-1">函数的调用栈 <a class="header-anchor" href="#函数的调用栈" aria-label="Permalink to &quot;函数的调用栈&quot;">​</a></h2><p>javascript的调用栈（ call stack ）是一种用来管理函数调用的数据结构，当一个函数被调用时，他会被添加到调用栈的顶部，当函数被执行完毕后，他会被从调用栈中移出。调用栈追寻后进先出的原则</p><ol><li>调用函数： 当代码执行到一个函数的调用时，该函数的信息（包括函数名和参数）被推送到调用栈的顶部</li><li>执行函数：被调用函数执行时，他的变量和局部上下文会被推入调用栈</li><li>嵌套调用：如果一个函数的内部又调用了其他函数，这些函数的信息也会被推送到调用栈的顶部，这样就形成了调用栈的嵌套结构</li><li>函数返回：当一个函数执行完毕，他会被从调用栈中弹出，控制权回到调用他的函数</li><li>栈的清空：当所有的函数都被执行完毕，调用栈就会变为空，这通常会发生在主程序执行完毕或者一个事件处理函数执行完毕后</li><li>如果一个调用栈变得太大（比如由于无限递归），会导致栈溢出。</li></ol>',8)]))}const u=e(l,[["render",o]]);export{p as __pageData,u as default};
